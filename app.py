# app.py: RegNarrative Auditor Streamlit Frontend
# Generated by RegNarrative_Auditor_Factory.ipynb

import streamlit as st
import os
import time
import logging

from langchain_google_genai import ChatGoogleGenerativeAI, GoogleGenerativeAIEmbeddings
from langchain_community.vectorstores.pgvector import PGVector
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnablePassthrough
from tenacity import retry, stop_after_attempt, wait_exponential

# --- Configuration ---
# Use Streamlit secrets for production deployment
GEMINI_API_KEY = st.secrets.get("GEMINI_API_KEY")
DB_CONNECTION_STRING = st.secrets.get("DB_CONNECTION_STRING")
COLLECTION_NAME = "reg_narrative_audits"

if not GEMINI_API_KEY or not DB_CONNECTION_STRING:
    st.error("Missing secrets: GEMINI_API_KEY or DB_CONNECTION_STRING. Please set them in your Streamlit app settings.")
    st.stop()

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Resilient API/DB Setup ---
@retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=2, max=10))
def initialize_vectorstore():
    logging.info("Initializing vector store connection with retry...")
    embeddings = GoogleGenerativeAIEmbeddings(
        model="text-embedding-004", 
        google_api_key=GEMINI_API_KEY
    )
    
    # PGVector will connect to the existing collection created in the notebook
    vectorstore = PGVector(
        connection_string=DB_CONNECTION_STRING,
        embedding_function=embeddings,
        collection_name=COLLECTION_NAME
    )
    return vectorstore

# --- RAG Chain Definition ---
def setup_rag_chain(vectorstore):
    retriever = vectorstore.as_retriever(search_kwargs={"k": 3})
    llm = ChatGoogleGenerativeAI(
        model="gemini-2.5-flash", 
        temperature=0.1, 
        google_api_key=GEMINI_API_KEY
    )

    SYSTEM_PROMPT = """
You are the RegNarrative Auditor Agent. Your task is to perform a multi-hop compliance audit.
1. Analyze the user's query and retrieve all relevant regulatory context from the provided documents.
2. Formulate a final audit conclusion based ONLY on the retrieved context.
3. Your output MUST explicitly cite the relevant policy or regulation (e.g., 'Regulation 401.A') from the documents as verifiable evidence.
4. If a transaction is non-compliant, state the specific consequence (e.g., 'immediate internal audit and a penalty of 5%').
"""

    prompt = ChatPromptTemplate.from_messages(
        [
            ("system", SYSTEM_PROMPT),
            ("human", "Audit Query: {query}\n\nRetrieved Context:\n{context}"),
        ]
    )

    def format_docs(docs):
        return "\n\n---\n\n".join([f"Source ({doc.metadata.get('source', 'Unknown')}): {doc.page_content}" for doc in docs])

    rag_chain = (
        {"context": retriever | format_docs, "query": RunnablePassthrough()}
        | prompt
        | llm
        | StrOutputParser()
    )
    return rag_chain

# --- Streamlit UI and Logic ---
st.set_page_config(layout="wide", page_title="RegNarrative Auditor")
st.title("üõ°Ô∏è RegNarrative Auditor: Agentic Compliance System")
st.caption("Verifiable, production-grade RAG powered by Gemini and pgvector.")

# Initialize vectorstore and RAG chain once
if 'rag_chain' not in st.session_state:
    try:
        with st.spinner("Connecting to pgvector and loading models..."):
            vectorstore_instance = initialize_vectorstore()
            st.session_state.rag_chain = setup_rag_chain(vectorstore_instance)
        st.success("System Ready!")
    except Exception as e:
        st.error(f"System Failed to Initialize. Check DB connection and secrets: {e}")
        st.stop()

# User Input
audit_query = st.text_area(
    "Enter Audit Query or Transaction Scenario:",
    "A financial transaction of $12,500 was completed with only a signature and a timestamp recorded. Is this compliant, and what is the consequence of non-compliance?",
    height=150
)

# Audit Button
if st.button("Run Compliance Audit", type="primary"):
    if not audit_query.strip():
        st.warning("Please enter an audit query.")
    else:
        st.subheader("Audit Conclusion")
        with st.spinner("Running agentic, multi-hop RAG..."):
            try:
                # Invoke the LangChain RAG
                result = st.session_state.rag_chain.invoke(audit_query)
                
                # Display the result
                st.markdown(result)
                
                # Simple Logging to console for operation traceability
                logging.info(f"Audit completed for query: '{audit_query[:50]}...'") # <-- THIS LINE IS NOW FIXED

            except Exception as e:
                st.error(f"An error occurred during audit execution. See logs for details. Error: {e}")
                logging.error(f"RAG Chain Execution Error: {e}")

st.markdown("---")
st.markdown("### Operational Metadata")
st.code(f"Model: gemini-2.5-flash\nVector Store: pgvector\nCollection: reg_narrative_audits")